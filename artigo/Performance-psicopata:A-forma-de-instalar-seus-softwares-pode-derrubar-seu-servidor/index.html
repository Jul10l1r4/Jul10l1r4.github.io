<!DOCTYPE html>
<html lang="pt-BR">
	<head>
      <meta charset="utf-8"/>
      <title>Shell script e performance psicopata üî™ ‚Äì stdout, echo printf ou cat com o here document? Veja qual se sai mais veloz	 | Julio Lira</title>	
      <!--link rel="icon" type="image/png" href="img/favicon.png" /-->
      <meta name="viewport" content="width=device-width, user-scalable=no"/>
      <link rel="stylesheet" href="https://jul10l1r4.github.io/Texto-farmatacao/principal.css"/>
      <link rel="stylesheet" href="../../css/layout.css"/>
      <meta name="author" content="Julio Lira"/>
			<link rel="icon" href="../../assets/jl.png" />
      <meta name="robots" content="index, follow">
      <meta property="og:site_name" content="https://jul10l1r4.github.io/" />
      <meta property="og:url" content="https://jul10l1r4.github.io/artigos/Shell-script-e-performance-psicopata-üî™--stdout/index.html" />
      <meta name="description" content="N√≥s que trabalhamos com bash queremos performance e baixo consumo em nossa infra n√£o √© mesmo? Ent√£o resolvi fazer uns testes de sa√≠da."/>
      <meta property="og:title" content="Shell script e performance psicopata üî™ ‚Äì stdout | Julio Lira">
      <meta property="og:image" content="parada1.png"/>
      <meta property="og:description" content="N√≥s que trabalhamos com bash queremos performance e baixo consumo em nossa infra n√£o √© mesmo? Ent√£o resolvi fazer uns testes de sa√≠da."/>
      <meta property="og:author" content="Julio Lira"/>
  <!-- twitter metatags-->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Shell script e performance psicopata üî™ ‚Äì stdout | Julio Lira">
  <meta name="twitter:description" content="N√≥s que trabalhamos com bash queremos performance e baixo consumo em nossa infra n√£o √© mesmo? Ent√£o resolvi fazer uns testes de sa√≠da">
  <meta name="twitter:image" content="parada1.png">
			<script src="../../Ecmascript/analiz.js"></script>
			<script async src="../../Ecmascript/scroll.js"></script>
<!-- Facilitar indexa√ß√£o de ferramentas de busca --->
	<script type="application/ld+json">
{
	"name":"Shell script e performance psicopata üî™ ‚Äì stdout | Julio Lira",
	"description":"N√≥s que trabalhamos com bash queremos performance e baixo consumo em nossa infra n√£o √© mesmo? Ent√£o resolvi fazer uns testes de sa√≠da",
	"author":"Julio Lira",
	"@type":"Organization",
	"url":"https://jul10l1r4.github.io/artigos/Shell-script-e-performance-psicopata-üî™--stdout/index.html",
	"image":"https://instagram.fnat2-1.fna.fbcdn.net/vp/c86b9975b58d82a3e5ea3526131a8d2a/5B146E0F/t51.2885-15/e35/26868816_181404315800705_76975572110016512_n.jpg",
	"headline":"Julio Lira",
  "@context":"http://schema.org",
  "contactPoint": {
					"@type": "ContactPoint",
					"email": "jul10l1r4@ufrn.edu.br"
				}
}
		 </script>
			
    </head>
    <body>
			<header style="background-image: url(../../assets/bg-ops.png)" id="top">
				<div id="to">
			    <h1>Shell script e performance psicopata üî™ ‚Äì stdout
						<!--img src="https://emojipedia-us.s3.amazonaws.com/thumbs/160/facebook/111/smirking-face_1f60f.png"/-->
					</h1>
				</div>
			</header>
			<a id="down" href="#conteudo">Veja qual a forma mais perform√°tica de sa√≠da no bash</a>
			<section class="medium-text">
				<p id="conteudo">
					Para n√≥s que cuidamos muitas vezes da infraestrutura dos servidores sabemos a import√¢ncia de performance em nossos processos executados principalmente em produ√ß√£o, e esse cuidado se torna em v√≠cio real
				</p>
				<p>
					√â bem natural que qualquer pessoa que seja dessa parte de infraestrutura em geral seja viciado loucamente em performance e baixo consumo de hardware, por mais parruda que seja a aplica√ß√£o sobrar nunca √© demais
				</p> 
				<figure>
					<img src="parada1.png" alt="Um psicopata doid√£o a√≠ do shell script e louco por performance"/>
					<figcaption>Eu quando estava fazendo o teste e tive o resultado esperado <span class="emoj">üòç</span>!</figcaption>
				</figure>
				<h2>Treta</h2>
				<p>
					O shell √© a coisa mais linda que temos nessa porra de vida, e como a nossa vida existem v√°rias formas de fazer a mesma coisa, s√≥ que uma delas dificilmente d√£o o mesmo resultado na quest√£o de performance, isso √© claro n√©?!
				</p>
				<p>
					E n√£o diferentemente disso acontece com o <code>echo</code>, temos algumas alternativas como por exemplo a que chamamos de here-document (<<) usada no <code>cat</code> (para sair no STDOU) e tamb√©m o <code>printf</code> que tem uma sintaxe bem parecida com a do <code>echo</code> e ainda tamb√©m fiz com o printf com here-document direcionando a <code>/dev/stdout</code>.
				</p>
				<p>
					E como qualquer viciado fiquei curioso em saber se eles se diferenciavam em performance nem que seja quest√£o de milissegundos, e sei que voc√™ s√≥ est√° lendo esse artigo porque tamb√©m √© um viciado como eu üíÄ.
				</p>
				<h2>ANALISANDO</h2>
				<p>
					A forma que achei mais style fodastica foi usando o here-document do cat, mano cola s√≥ na sintaxe:
				</p>
				<figure>
					<script src="https://gist.github.com/Jul10l1r4/9516c905cd058ad651b812fe88d7084a.js"></script>
					<figcaption>A sa√≠da sa√≠da ser√° o texto na segunda linha</figcaption>
				</figure>
				<p>
					Mas deixei pra l√° o meu style super hacker fod√£o e me liguei na performance, ent√£o obviamente ele foi o primeiro que eu teste, usando o strace pude mapear as requisi√ß√µes feitas ao executar aquele c√≥digo e tive uma sa√≠da um pouco verbosa, mas estudaremos as sa√≠das quando formos comparar os diferentes m√©todos.
				</p>
				<p>
					Mas deixando de conversa mole vamos as paradas, primeiramente vamos aos testes.
				</p>
				<p>
					Outra forma de testar foi usando o printf e apontando para escrever em <code>/dev/stdout</code> que √© um link simb√≥lico que aponta para outro link simb√≥lico que aponta para outro, ele tem tantos links assim pelo simples motivo de identificar qual a TTY logada e coisas do tipo, o segundo link se localiza em <code>/proc/self/fd/1</code> e o primeiro no meu caso estava dentro de <code>/dev/pts/0</code>.
				</p>
				<h2>AOS TESTES</h2>
				<p>
					Com minha duvida do caralho eu fiz um script afim de medir a porra dessa velocidade, e saber qual na pr√°tica era que iria executar mais r√°pido, e at√© que fim pude descobrir, meu teste foi simples, baseado em quatro fun√ß√µes onde elas exibiam 10000 vezes uma s√©rie de caracteres rand√¥micos ("@#$%%&*I&FDFSRWEGsy‚Ç¨¬Æ¬≥¬Æ≈ß≈ãƒë√∞ƒë√∞≈ã√¶") e sem quebra de linhas ou espa√ßos e nem tabs.
				</p>
				<figure>
					<script src="https://gist.github.com/Jul10l1r4/10d8ae6211950d353e652bcdd6b61875.js"></script>
					<figcaption>Ent√£o fiz esse script pra verificar o resultado</figcaption>
				</figure>
				<figure>
					<img src="teste1.jpeg" alt="Sa√≠da no terminal branchmark, performance do echo">
					<figcaption>Sim, o echo foi mais r√°pido em todas as tentativas</ficaption>
				</figure>
				<p>
					Na sa√≠da acima vemos que o echo foi mais r√°pido em quest√£o de milessegundos, e o printf direcionando para o stdout foi o segundo mais veloz, com 0,102s, o printf ficou em terceiro lugar por 1 ms e o cat usando here-document ficou com <strong>a pior performance</strong> com 0,174s.
				<p>
				<figure>
					<img src="minhaReacao.gif" alt="Hello mutherafucka"></script>
					<figcaption>WTF, o resultado foi totalmente o contr√°rio, PQP</figcaption>
				</figure>
				<h2>CAT (da morte)</h2>
				<p>
					O cat na pr√°tica e ap√≥s ser executado cria um espa√ßo din√¢mico na mem√≥ria para a aloca√ß√£o, e pra isso √© necess√°rio ela chamar tamb√©m um descritor de arquivo fd (file descriptor) e saber o estado do arquivo, se existe ou se pode ou nao pode ser lido, conforme est√£o no padr√£o do m√≥dulo do libc <code>unistd.h</code> pode ser encontrado em <code>/usr/include/unistd.h</code> definindo: STDIN_FILENO, STDOUT_FILENO e STDERR_FILENO, que √© respectivamente o n√∫mero 1, 2 e 3.
				</p>
				<p>
					Outra forma que colabora para que sua execu√ß√£o venha demorar mais √© a fun√ß√£o <code>read()</code>, para que ele imprima √© necess√°rio que tenham entrada de dados, e o cat n√£o armazenou a entrada, a √∫nica que ele armazenou foi o primeiro argumento no qual foi ignorado por n√£o ser um arquivo, e esse passo faz com que ela receba armazene em uma vari√°vel, e √© aqui que a porca torce o rabo! 
				</p>
				<figure>
					<img src="porca.jpeg" alt="Rabo de porco"></script>
					<figcaption>WTF, o resultado foi totalmente o contr√°rio, PQP</figcaption>
				</figure>
				<p>
					Se voc√™ executar <code>strace cat</code>, ele ir√° parar e esperar uma entrada em <code>read(0,</code> e ap√≥s a entrada ele executa o script normalmente.
				</p>
				<p>
					Esses passos fazem com que ele perca o tempo suficiente para que tenha uma maior demanda de tempo e aumenta o tempo de sua execu√ß√£o.
				</p>
				<h2>Printf VS Echo</h2>
				<p>
					Em nosso exemplo foi feito um teste de explos√£o de car√°cteres em cada fun√ß√£o e foi analisada a performance, ok... Mas e se n√≥s tent√°ssemos criar um script que executaria cada fun√ß√£o por v√°rias vezes?
				</p>
				<p>
					<i>Como assim?</i>
				</p>
				<blockquote>
					Se n√≥s escrevermos um la√ßo de repeti√ß√£o pra cada fun√ß√£o de impress√£o na tela poderemos verificar qual o mais perform√°tico em uma perspectiva de varias vezes no c√≥digo ser chamada a mesma fun√ß√£o.
				</blockquote>
				<figure>
					<script src="https://gist.github.com/Jul10l1r4/ca98011f88bc2ae49aa925450b0e7373.js"></script>
					<figcaption>Ent√£o verifiquei realizando esse teste</figcaption>
				</figure>
				<figure>
					<img src="teste-louco.jpeg" alt="Teste de performance branchmark entre echo cat e printf"/>
					<figcaption>Notei insconscistencia entre o resultado do echo e o do printf puro</figcaption>
				<p>
					Notei que diferentes vezes que eu realizava o mesmo teste o resultado do echo era mais r√°pido e outros mais lento do que o da fun√ß√£o no printf, isso me incomodou bastante, mas se notarmos o embora o resultado seja diferente, as duas fun√ß√µes na pr√°tica s√£o muito semelhantes, mas existem algumas diferen√ßas que acho interessante detalhar.
				</p>
				<h2>Estudando o fruto desde a raiz</h2>
				<p>
					As duas fun√ß√µes s√£o de cara executadas pelo bash e de l√° √© direcionado a abrir um outro bin√°rio que √© o correspondente que no caso √© o <strong>echo</strong> e o <strong>printf</strong> elas duas s√£o invocadas de <code>/usr/bin/bin√°rio</code> e √© feita toda a aloca√ß√£o, defini√ß√£o de leitura e armazenamento de "arquivo" (como √© tratado qualquer coisa nos Unix-likes), em um determinado momento que est√° tudo certo ele chega a criar o arquivo virtual para direcionar ao <code>STDOUT</code> (j√° citado anteriormente) e em que a n√≠vel de sistema ele chama a fun√ß√£o <code>fstat</code> do m√≥dulo C <code>stat</code> (que pode ser encontrado em /usr/include/(plataforma)-linux-gnu/sys/stat.h) em que √© alogo como <code>fstat(1, {st_mode=S_IFCHR|0620 ...</code>, o <code>st_mode</code> √© o valor de configura√ß√£o que seta qual ser√° o tipo de arquivo a ser retornado, e a op√ß√£o preenchida foi <code>S_IFCHR</code> que √© significa que o arquivo √© de caracteres especiais, e seguido isso usa-se um pipe ("|" Essse s√≠mbolo) no trecho mostra <code>0620</code> que se refere a permiss√£o de arquivo, no caso ele n√£o ter√° permiss√£o especial (stickbit, suid nem sgid) o usu√°rio dono do arquivo poder√° escrever e ler e o grupo do usu√°rio poder√° apenas escrever naquele arquvo que voc√™ p√¥s como entrada na fun√ß√£o, de modo leg√≠vel a permiss√£o seria <code>wr- w-- ---</code>.
				</p>
				<p>
					E como segundo argumento encapsulado, temos <code>st_rdev=makedev(136, 2)</code>, o <code>st_rdev</code> √© uma vari√°vel de configura√ß√£o de <strong>Device ID</strong> (identifica se o arquivo √© caractere ou bloco especial), essa vari√°vel retorna um valor inteiro, e passam dois argumentos, sendo o primeiro o identificador <code>Device ID</code> e nomeado de <code>Major</code> e o segundo √© o identificador da inst√¢ncia espec√≠fica do <code>Device ID</code> esses dois argumentos parecem confusos mas assim essa fun√ß√£o faz como o mknod, onde √© criado um arquivo de rela√ß√£o de kernel no diret√≥rio <code>/dev/</code>.
				</p>
				<blockquote>
					A cria√ß√£o de um arquivo especial do tipo: bloco, FIFO e caracter. √â totalmente util para o menor consumo de dados no armazenamento do mesmo, j√° que o arquivo se sobreescreve e n√£o mant√©m sempre aumentando o conte√∫do a cada altera√ß√£o, al√©m de que o arquivo em s√≠ √© salvo como o arquivo que estamos estudando agora, na pr√°tica ele √© salvo em um estado de condena√ß√£o ap√≥s execu√ß√£o e quase imposs√≠vel se quer notar alguma altera√ß√£o no sistema.
				</blockquote>
				<p>
					Ap√≥s estudar todos esses padr√µes que coincidem entre os dois programas, notamos a total e unica diferen√ßa quase que insignificante na fun√ß√£o que √© chamada abaixo, a <code>write</code> (M√≥dulo pode ser encontrado em /usr/include/unistd.h), em nosso trecho de teste podemos pegar <code>write(1, "trecho de teste\n", 16trecho de teste)</code>, sendo usada a fun√ß√£o principal afim da execu√ß√£o, a fun√ß√£o write tem tr√™s argumentos, sendo o primeiro o <code>__fd</code>(File descriptor) comentado j√° anteriormente, o segundo o texto, chamado de <code>__buf</code> e o terceiro e ultimo sendo um valor inteiro da quantidade de bytes, chamada de <code>__nbyte</code>. no caso do echo ele acrescenta apenas 1 byte a mais, que √© a quebra de linha <code>\n</code> (que √© identificado como 10 em ascii), j√° o <code>printf</code> apenas imprime o texto passado, sem que haja quebra de linha e assim faz com que seja "mais veloz", a diferen√ßa √© t√£o detalhista que nem se quer um teste bem projetado poderia medir, tendo em vista que ap√≥s calcular e terminar o primeiro procedimento o processador j√° estar√° quente, ou j√° teria armazenado dados a mais, tamb√©m considerando a temperatura local, a corrente de vento e por m√≠nimo que seja a mudan√ßa ela surtar√° efeito no conometro.
				</p>
				<h2>Conclus√£o</h2>
				<p>
					Sendo isso √© poss√≠vel notar que o <code>printf</code> saiu mais veloz em varias chamadas repetidas, e o echo se saiu mais veloz em apenas uma chamada de uma vez, mesmo n√£o havendo diferen√ßas relevantes entre as duas. <a href="https://github.com/Jul10l1r4/Stdout-veloz/" target="_blank">Fa√ßa voc√™ mesmo</a> teste em sua plataforma, verifique voc√™ mesmo, as vezes nem sempre o <code>printf</code> ser√° aconselhado, j√° que pode ser usado o echo e ele j√° terminar√° em uma quebra de linha, sem precisar de que digite o <code>\n</code>, al√©m de tudo isso os comandos com formata√ß√£o e colora√ß√£o, s√£o todos suportados por padr√£o no printf (tanto no bash quanto no C, que tamb√©m pode ser usado o write, o que seria mais low-level), j√° o <code>echo</code> precisaria passar o par√¢metro <code>-e</code>.
				</p>
				<p>
					Dada as m√©tricas, cabe a voc√™ estudar a sua situa√ß√£o e verificar qual o que melhor se encaixa para seu ambiente, sabemos que 1 ms faz toda a diferen√ßa em nossos servidores :)
				</p>
			</section>
			<footer class="separador-top top6">
       <br/>
				<a href="https://jul10l1r4.github.io/">
					‚Üê Ir para a HOME
				</a>
        |
				<a href="http://jul10l1r4.github.io/HTTP_-_Resposta/">
					Mantenha a seguran√ßa de sua p√°gina, HTTP Meme resposta ‚Üí
				</a>
			</footer>
    </body>
  </html>		
